import pytest
from ToolboxClass import LRRT
import os
import pandas as pd 
from simpledbf import Dbf5
import shutil 
import grass.script as grass
from grass.script import array as garray
import grass.script.setup as gsetup
from grass.pygrass.modules.shortcuts import general as g
from grass.pygrass.modules.shortcuts import raster as r
from grass.pygrass.modules import Module
from grass_session import Session
import copy 
import numpy as np 

os.environ.update(dict(GRASS_COMPRESS_NULLS='1',GRASS_COMPRESSOR='ZSTD',GRASS_VERBOSE='1'))

def Dbf_To_Dataframe(file_path):
    """Transfer an input dbf file to dataframe
    
    Parameters
    ---------- 
    file_path   : string
    Full path to a shapefile 
    
    Returns:
    -------
    dataframe   : datafame 
    a pandas dataframe of attribute table of input shapefile    
    """
    tempinfo = Dbf5(file_path[:-3] + "dbf")
    dataframe = tempinfo.to_dataframe()
    return dataframe
    
def Return_Raster_As_Array(grassdb,grass_location,raster_mn): 
    """Transfer an rater in grass database into np array
    Parameters
    ---------- 
    grassdb         : string
    Full path to a grass database 
    grass_location  : string
    location name in that grass database   
    raster_mn       : string
    raster name 
        
    Returns:
    -------
    Array            : array  
    np array of the raster. 
       
    """    
    PERMANENT = Session()
    PERMANENT.open(gisdb=grassdb, location=grass_location,create_opts='')
    Array = copy.deepcopy(garray.array(mapname=raster_mn))
    PERMANENT.close()
    return Array
        
def test_RoutingNetworkTopologyUpdateToolset_riv():
    """test function that will: 
    Calculate hydrological paramters for each subbasin generated by
    "AutomatedWatershedsandLakesFilterToolset". The result generaed 
    by this tool can be used as inputs for Define_Final_Catchment 
    and other post processing tools
    """ 
    
    ###Floder where store the inputs for tests function
    Data_Folder  = './testdata/Required_data_to_start_from_dem/'
    
    ###Folder where store the expected resuts        
    Final_Result_Folder_Expected     = os.path.join('./testdata','Final_output_folder','Expected_InDEM')
    Temporary_Result_Folder_Expected = os.path.join('./testdata','Temporary_output_folder','Expected_InDEM')

    ###Folder where the output will be generated     
    Temporary_Result_Folder_Result   = os.path.join('./testdata','Temporary_output_folder','testout')
    Final_Result_Folder_Result       = os.path.join('./testdata','Final_output_folder','testout')    
    shutil.rmtree(Temporary_Result_Folder_Result,ignore_errors=True)
    
    ###The pathes for all inputs 
    Path_DEM_big           = os.path.join(Data_Folder, 'DEM_big_merit.tif')
    Path_DEM_small         = os.path.join(Data_Folder, 'DEM_samll_merit.tif')
    Path_Lake_ply          = os.path.join(Data_Folder, 'HyLake.shp')
    Path_bkf_wd            = os.path.join(Data_Folder, 'Bkfullwidth_depth.shp')
    Path_Landuse           = os.path.join(Data_Folder, 'landuse.tif')
    Path_Roughness_landuse = os.path.join(Data_Folder, 'Landuse.csv')
    
    ###Generate test resuts, for option 1 
    RTtool=LRRT(dem_in = Path_DEM_small,WidDep = Path_bkf_wd,
               Lakefile = Path_Lake_ply,Landuse = Path_Landuse,
               Landuseinfo = Path_Roughness_landuse,
               OutputFolder = Final_Result_Folder_Result,
               TempOutFolder = Temporary_Result_Folder_Result,
               )
    ### test using extent of input dem as processing extent 
    RTtool.Generatmaskregion()
    RTtool.Generateinputdata()
    RTtool.WatershedDiscretizationToolset(accthresold = 500)
    RTtool.AutomatedWatershedsandLakesFilterToolset(Thre_Lake_Area_Connect = 0,
                                                    Thre_Lake_Area_nonConnect = 0)
    RTtool.RoutingNetworkTopologyUpdateToolset_riv(projection = 'EPSG:3573')

    
    """Evaluate total number of subbasin, total subbasin area, total river length
       and total lake area. 
    N_Cat is the total number of subbasins in the simplified routing network 
    len_Riv is the total river length in the simplified routing network 
    Bas_Area is the total subbasin area in the simplified routing network
    Lake_Area is the total lake area in the simplified routing network     
    """ 

    ### transfer expected siplified product into pandas dataframe
    Expect_Finalriv_info_ply = Dbf_To_Dataframe(os.path.join(Final_Result_Folder_Expected,'finalriv_info_ply.shp')).sort_values(by=['SubId'])
    ### calcuate expected total number of catchment:Expect_N_Cat
    Expect_N_Cat = len(Expect_Finalriv_info_ply)
    ### calcuate expected total river length :Expect_len_Riv
    Expect_len_Riv = sum(Expect_Finalriv_info_ply['RivLength'])
    ### calcuate expected total basin area :Expect_Bas_Area
    Expect_Bas_Area = sum(Expect_Finalriv_info_ply['BasArea'])
    ### calcuate expected total lake area: Expect_Lake_Area
    Expect_Lake_Area = sum(Expect_Finalriv_info_ply['LakeArea'])

    ### transfer resulted siplified product into pandas dataframe    
    Result_Finalriv_info_ply = Dbf_To_Dataframe(os.path.join(Final_Result_Folder_Result,'finalriv_info_ply.shp')).sort_values(by=['SubId'])
    ### calcuate resulted total number of catchment:Result_N_Cat
    Result_N_Cat = len(Result_Finalriv_info_ply)
    ### calcuate resulted total river length :Result_len_Riv
    Result_len_Riv = sum(Result_Finalriv_info_ply['RivLength'])
    ### calcuate resulted total basin area :Result_Bas_Area
    Result_Bas_Area = sum(Result_Finalriv_info_ply['BasArea'])
    ### calcuate resulted total lake area: Result_Lake_Area
    Result_Lake_Area = sum(Result_Finalriv_info_ply['LakeArea'])
    
    ### compare Expect_N_Cat and Result_N_Cat
    assert Expect_N_Cat == Result_N_Cat
    ### compare Expect_len_Riv and Result_len_Riv
    assert Expect_len_Riv == pytest.approx(Result_len_Riv, 0.1)
    ### compare Expect_Bas_Area and Result_Bas_Area
    assert Expect_Bas_Area == pytest.approx(Result_Bas_Area, 0.1)
    ### compare Expect_Lake_Area and Result_Lake_Area    
    assert Expect_Lake_Area == pytest.approx(Result_Lake_Area, 0.1)
    

    """Evaluate lake polygon files 
    Con_Lake_Ply is the lake polygon that connected by river network 
    Non_Con_Lake_Ply is the lake polygon that did not connected by 
    river network 
    """ 
    ### transfer expected siplified connected lake polygon  into pandas dataframe Expect_Con_Lake_Ply
    Expect_Con_Lake_Ply      = Dbf_To_Dataframe(os.path.join(Final_Result_Folder_Expected,'Con_Lake_Ply.shp'))
    ### transfer expected siplified non connected lake polygon  into pandas dataframe Expect_Non_Con_Lake_Ply
    Expect_Non_Con_Lake_Ply  = Dbf_To_Dataframe(os.path.join(Final_Result_Folder_Expected,'Non_Con_Lake_Ply.shp'))
    
    ### transfer resulted siplified connected lake polygon  into pandas dataframe Result_Con_Lake_Ply
    Result_Con_Lake_Ply      = Dbf_To_Dataframe(os.path.join(Final_Result_Folder_Result,'Con_Lake_Ply.shp'))
    ### transfer resulted siplified non connected lake polygon  into pandas dataframe Result_Non_Con_Lake_Ply
    Result_Non_Con_Lake_Ply  = Dbf_To_Dataframe(os.path.join(Final_Result_Folder_Result,'Non_Con_Lake_Ply.shp'))
    
    ### compare two pandas dataframe Expect_Con_Lake_Ply and Result_Con_Lake_Ply
    assert Result_Con_Lake_Ply.equals(Expect_Con_Lake_Ply)
    ### compare two pandas dataframe Expect_Non_Con_Lake_Ply and Result_Non_Con_Lake_Ply
    assert Result_Non_Con_Lake_Ply.equals(Expect_Non_Con_Lake_Ply)
    RTtool.Output_Clean()
    